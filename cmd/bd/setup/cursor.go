package setup

import (
	"fmt"
	"os"
	"path/filepath"
)

const cursorRulesTemplate = `# Beads Issue Tracking
# Auto-generated by 'bd setup cursor' - do not remove these markers
# BEGIN BEADS INTEGRATION

This project uses [Beads (bd)](https://github.com/steveyegge/beads) for issue tracking.

## Core Rules
- Track ALL work in bd (never use markdown TODOs or comment-based task lists)
- Use ` + "`bd ready`" + ` to find available work
- Use ` + "`bd create`" + ` to track new issues/tasks/bugs
- Use ` + "`bd sync`" + ` at end of session to sync with git remote
- Git hooks auto-sync on commit/merge

## Quick Reference
` + "```bash" + `
bd prime                              # Load complete workflow context
bd ready                              # Show issues ready to work (no blockers)
bd list --status=open                 # List all open issues
bd create --title="..." --type=task  # Create new issue
bd update <id> --status=in_progress  # Claim work
bd close <id>                         # Mark complete
bd dep <from> <to>                    # Add dependency (from blocks to)
bd sync                               # Sync with git remote
` + "```" + `

## Workflow
1. Check for ready work: ` + "`bd ready`" + `
2. Claim an issue: ` + "`bd update <id> --status=in_progress`" + `
3. Do the work
4. Mark complete: ` + "`bd close <id>`" + `
5. Sync: ` + "`bd sync`" + ` (or let git hooks handle it)

## Context Loading
Run ` + "`bd prime`" + ` to get complete workflow documentation in AI-optimized format (~1-2k tokens).

For detailed docs: see AGENTS.md, QUICKSTART.md, or run ` + "`bd --help`" + `

# END BEADS INTEGRATION
`

// InstallCursor installs Cursor IDE integration
func InstallCursor() {
	rulesPath := ".cursor/rules/beads.mdc"

	fmt.Println("Installing Cursor integration...")

	// Ensure parent directory exists
	if err := EnsureDir(filepath.Dir(rulesPath), 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	// Write beads rules file (overwrite if exists)
	if err := atomicWriteFile(rulesPath, []byte(cursorRulesTemplate), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error: write rules: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("\n✓ Cursor integration installed\n")
	fmt.Printf("  Rules: %s\n", rulesPath)
	fmt.Println("\nRestart Cursor for changes to take effect.")
}

// CheckCursor checks if Cursor integration is installed
func CheckCursor() {
	rulesPath := ".cursor/rules/beads.mdc"

	if _, err := os.Stat(rulesPath); os.IsNotExist(err) {
		fmt.Println("✗ Cursor integration not installed")
		fmt.Println("  Run: bd setup cursor")
		os.Exit(1)
	}

	fmt.Println("✓ Cursor integration installed:", rulesPath)
}

// RemoveCursor removes Cursor integration
func RemoveCursor() {
	rulesPath := ".cursor/rules/beads.mdc"

	fmt.Println("Removing Cursor integration...")

	if err := os.Remove(rulesPath); err != nil {
		if os.IsNotExist(err) {
			fmt.Println("No rules file found")
			return
		}
		fmt.Fprintf(os.Stderr, "Error: failed to remove file: %v\n", err)
		os.Exit(1)
	}

	fmt.Println("✓ Removed Cursor integration")
}
